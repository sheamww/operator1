<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pillar of Dots with Collision Avoidance</title>
  <style>
    html, body {
      margin: 0; 
      padding: 0; 
      height: 100%;
      overflow: hidden; 
      background: #000;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Container for Three.js Canvas */
    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background: radial-gradient(circle at center, #070b34, #000 80%);
    }
  </style>
</head>
<body>
  <!-- Three.js Scene Container -->
  <div id="scene-container"></div>

  <!-- Three.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // =============================
    // 1) Scene & Camera Setup
    // =============================
    let scene, camera, renderer;
    let particleSystem, uniforms, clock;
    const container = document.getElementById('scene-container');

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // =============================
    // 2) Particle Swirl Geometry
    // =============================
    const particleCount = 20000;
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
      const r = Math.random() * 5 + 10;          // radial distance
      const angle = Math.random() * Math.PI * 4;   // swirl angle
      const y = (Math.random() - 0.5) * 80;        // vertical spread

      positions[i * 3]     = r * Math.cos(angle);
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = r * Math.sin(angle);

      speeds[i] = (Math.random() * 0.5) + 0.5;     // swirling speed factor
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

    // =============================
    // 3) Shaders (Swirl + Collision Avoidance)
    // =============================
    uniforms = {
      uTime:   { value: 0 },
      uColor1: { value: new THREE.Color('#0ed2f7') },
      uColor2: { value: new THREE.Color('#ffffff') },
      uMouse3D: { value: new THREE.Vector3(0, 0, 0) }, // mouse position in 3D
      uAvoidThreshold: { value: 8.0 }                  // collision avoidance threshold
    };

    const vertexShader = `
      uniform float uTime;
      uniform vec3  uMouse3D;
      uniform float uAvoidThreshold;
      attribute float aSpeed;
      varying float vFade;

      void main() {
        vec3 pos = position;

        // Rotate to create a swirling effect
        float swirlAngle = uTime * 0.2 * aSpeed;
        float cosA = cos(swirlAngle);
        float sinA = sin(swirlAngle);
        vec3 rotatedPosition;
        rotatedPosition.x = cosA * pos.x - sinA * pos.z;
        rotatedPosition.y = pos.y;
        rotatedPosition.z = sinA * pos.x + cosA * pos.z;

        // Compute fade based on distance
        vFade = 1.0 - clamp(length(pos) / 60.0, 0.0, 1.0);

        // Collision avoidance: push particle away from mouse if too close
        float distToMouse = distance(rotatedPosition, uMouse3D);
        if(distToMouse < uAvoidThreshold) {
          vec3 pushDir = normalize(rotatedPosition - uMouse3D);
          float force = 1.0 - (distToMouse / uAvoidThreshold);
          rotatedPosition += pushDir * force * 2.0;
        }

        gl_Position = projectionMatrix * modelViewMatrix * vec4(rotatedPosition, 1.0);
        gl_PointSize = 2.0;
      }
    `;

    const fragmentShader = `
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      varying float vFade;

      void main() {
        vec3 color = mix(uColor2, uColor1, vFade);
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // =============================
    // 4) Mouse Interaction via Raycasting
    // =============================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0, 0);
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // z=0 plane

    window.addEventListener('pointermove', (event) => {
      mouse.x =  (event.clientX / window.innerWidth)  * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // =============================
    // 5) Animation Loop
    // =============================
    clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();
      uniforms.uTime.value = elapsed;

      // Subtle camera drift
      camera.position.x = Math.sin(elapsed * 0.2) * 5;
      camera.position.y = Math.cos(elapsed * 0.1) * 3;
      camera.lookAt(scene.position);

      // Update mouse 3D position via raycasting onto the z=0 plane
      raycaster.setFromCamera(mouse, camera);
      const intersectPos = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPos);
      uniforms.uMouse3D.value.copy(intersectPos);

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
